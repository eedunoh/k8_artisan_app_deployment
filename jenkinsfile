pipeline {
    agent any

    // I parametized my terraform workflow
    parameters {
        booleanParam(name: 'PRE_INFRASTRUCTURE', defaultValue: false, description: 'select this option to build all pre-infrastructure configurations like Sonarqube Analysis, Trivy Scans, Image build and push to DockerHub')
        booleanParam(name: 'TERRAFORM_INIT_AND_PLAN', defaultValue: false, description: 'select this option to initialize and plan terraform configurations')
        booleanParam(name: 'TERRAFORM_APPLY', defaultValue: false, description: 'select this option to apply terraform configurations')
        booleanParam(name: 'CLUSTER_DEPLOYMENTS', defaultValue: false, description: 'select this option to deploy app and resources to k8 cluster')
        booleanParam(name: 'TERRAFORM_DESTROY', defaultValue: false, description: 'select this option to destroy terraform configurations')
    }

    environment {
        APP_FOLDER='cluster_app_and_resources_deployments/app_folder'
        IMAGE_NAME='jackedu/artisan_app'
        IMAGE_TAG='latest'
        GIT_URL='https://github.com/eedunoh/k8_artisan_app_deployment.git'
        K8_CLUSTER_NAME='artisian_app_cluster'
        K8_CLUSTER_REGION='eu-north-1'
        MANIFESTS_DIR='cluster_app_and_resources_deployments/manifests_yaml'
        TERRAFORM_DIR='cluster_app_and_resources_deployments/terraform_files'
        TF_PLAN_FILE='tfplan.binary'
        SONAR_PROJECT_NAME='artisan_app_sonar'
        EKS_APP_NODE='app_worker_node' 
        EKS_MONITORING_NODE='monitoring_node'

        // tool 'sonar-scanner' - is a Jenkins command that means: "Go find where the program named 'sonar-scanner' is installed on this computer.
        SCANNER_HOME = tool 'sonar-scanner'
    }


    stages {

        // Clone the git repository/work area
        stage('Clone Git Repository') {
            steps {
                echo "Cleaning workspace and cloning gir repositoy..."
                deleteDir()
                git branch: 'main', url: "${GIT_URL}"
                sh 'ls -lart'
            }
        }


        // Scans Code for quality, maintainability, bugs, code smells, test coverage
        stage('SonarQube Analysis') {
            when {
                expression { params.PRE_INFRASTRUCTURE }
            }
            steps {
                withSonarQubeEnv('sonar') {
                    sh "$SCANNER_HOME/bin/sonar-scanner -Dsonar.projectName=${SONAR_PROJECT_NAME} -Dsonar.projectKey=${SONAR_PROJECT_NAME}"
                }
            }
        }


        // Scans your local source code directory (before you build the image) for security vulnerabilities (CVEs), secrets and misconfigurations.
        stage('Trivy FS Scan') {
            when {
                expression { params.PRE_INFRASTRUCTURE }
            }
            steps {
                sh 'trivy fs --format table -o trivy-fs-report.html .'
            }
        }


        // Your Trivy scan report will be stored in a file. This stage lets you view your scan report on jenkins UI (or terminal).
        stage('Publish Trivy File System Scan Report') {
            when {
                expression { params.PRE_INFRASTRUCTURE }
            }
            steps {
                publishHTML([
                    reportDir: '.',                      // directory where the HTML file is saved
                    reportFiles: 'trivy-fs-report.html',
                    reportName: 'Trivy File System Report',
                    allowMissing: false,
                    keepAll: true,                       // keep old reports from previous builds
                    alwaysLinkToLastBuild: true
                ])
            }
        }


        // Build docker image
        stage('Build Docker Image') {
            when {
                expression { params.PRE_INFRASTRUCTURE }
            }
            steps {
                echo "Building Docker image: ${IMAGE_NAME}:${IMAGE_TAG}"
                dir("${APP_FOLDER}") {
                    script {
                        dockerImage = docker.build("${IMAGE_NAME}:${IMAGE_TAG}")
                    }
                }
            }
        }


        // Clean up Docker build cache
        stage('Clean Docker Builder Cache') {
            when {
                expression { params.PRE_INFRASTRUCTURE }
            }
            steps {
                sh 'docker builder prune -a -f'
            }
        }


        // Push docker image to docker registry (dockerhub)
        stage('Push Docker Image to Docker Hub') {
            when {
                expression { params.PRE_INFRASTRUCTURE }
            }
            steps {
                echo "🚀 Pushing Docker image to Docker Hub..."
                script {
                    docker.withRegistry('https://index.docker.io/v1/', 'my_docker_hub_secrets') {
                        dockerImage.push("${IMAGE_TAG}")
                    }
                }
            }
        }
    

        stage('Terraform Init') {
            when {
                expression { params.TERRAFORM_INIT_AND_PLAN }
            }
            steps{
                echo "⚙️ Initializing Terraform..."
                withCredentials([[
                    $class: 'AmazonWebServicesCredentialsBinding',
                    credentialsId: 'my_aws_credentials'
                ]]) {
                    dir("${TERRAFORM_DIR}") {
                        sh '''
                            echo "======= Terraform Init ======="
                            terraform init
                        '''
                    }
                }
            }
        }


        stage('Terraform Plan') {
            when {
                expression { params.TERRAFORM_INIT_AND_PLAN }
            }
            steps {
                echo "🔍 Running Terraform Plan..."
                withCredentials([[
                    $class: 'AmazonWebServicesCredentialsBinding',
                    credentialsId: 'my_aws_credentials'
                ]]) {
                    dir("${TERRAFORM_DIR}") {
                        sh """
                            echo "======= Terraform Plan ======="
                            terraform plan -out=${TF_PLAN_FILE}
                            terraform show -no-color ${TF_PLAN_FILE} > tfplan.txt
                        """
                    }
                    archiveArtifacts artifacts: "${TERRAFORM_DIR}/${TF_PLAN_FILE}, ${TERRAFORM_DIR}/tfplan.txt", onlyIfSuccessful: true
                }
            }
        }

        
        stage('Terraform Apply') {
            when {
                expression { params.TERRAFORM_APPLY }
            }
            steps {
                echo "🚀 Applying Terraform Plan..."
                withCredentials([[
                    $class: 'AmazonWebServicesCredentialsBinding',
                    credentialsId: 'my_aws_credentials'
                ]]) {
                    dir("${TERRAFORM_DIR}") {
                        sh """
                            echo "======= Terraform Apply ======="
                            terraform apply -auto-approve ${TF_PLAN_FILE}
                        """
                    }
                }
            }
        }


        stage('Deploy To Kubernetes Cluster') {
            when {
                expression { params.CLUSTER_DEPLOYMENTS }
            }
            steps {
                echo "🚀 Deploying application and resources to Kubernetes cluster..."
                withCredentials([[
                    $class: 'AmazonWebServicesCredentialsBinding',
                    credentialsId: 'my_aws_credentials'
                ]]) {
                    dir("${MANIFESTS_DIR}") {
                        sh '''

                    # Set up kubeconfig for EKS
                    aws eks --region ${K8_CLUSTER_REGION} update-kubeconfig --name ${K8_CLUSTER_NAME}


                    # Helm was installed in the cicd (jenkins) dockerfile. So all we have to do here is to check helm version.                        
                    helm version


                    # Add Helm repos for nginx ingress and prometheus
                    helm repo add ingress-nginx https://kubernetes.github.io/ingress-nginx
                    helm repo add prometheus-community https://prometheus-community.github.io/helm-charts
                    helm repo update


                    # Add karpenter to helm and upgrade it. You will also update/add other attributes like cluster_name, karpenter controller role and namespace
                    helm repo add karpenter https://charts.karpenter.sh
                    helm upgrade --install karpenter karpenter/karpenter \
                    --namespace karpenter --create-namespace \
                    --set serviceAccount.annotations."eks\\.amazonaws\\.com/role-arn"=arn:aws:iam::337909745504:role/KarpenterControllerRole \
                    --set clusterName=${K8_CLUSTER_NAME} \
                    --set clusterEndpoint=$(aws eks describe-cluster --name ${K8_CLUSTER_NAME} --query "cluster.endpoint" --output text)

                    

                    # When Karpenter (or any node) joins your EKS cluster, the EC2 instance must be able to authenticate with the cluster. To do this, we need to update the ConfigMap.
                    kubectl apply -f karpenter-aws-auth.yml



                    # Create provisioners. These will create the node groups and get them ready for the pods to be scheduled.
                    kubectl apply -f karpenter_app_worker_nodes.yml

                    kubectl apply -f karpenter_monitoring_nodes.yml



                    # app-worker-node and monitoring-node Provisioners are now registered in your cluster. 
                    # Karpenter will use these definitions to launch EC2 instances whenever pods need scheduling and no suitable node exists.
                    # Nodes have not necessarily spun up yet, you will see new EC2 instances created automatically once pods are pending and need scheduling.
                    # kubectl get nodes --show-labels - will show you all nodes and labels + other attributes.



                    # Install NGINX ingress controller
                    helm upgrade --install ingress-nginx ingress-nginx/ingress-nginx --namespace ingress-nginx --create-namespace --wait --timeout 10m


                    # Deploy application (Deployment + Service)
                    kubectl apply -f deployment-service.yml



                    # Install Prometheus + Grafana stack (release name = monitoring)
                    helm upgrade --install monitoring prometheus-community/kube-prometheus-stack -f kube_prometheus_values.yml --wait --timeout 10m



                    # Apply ingress rules/ paths based routing
                    kubectl apply -f ingress.yml
                        '''
                    }
                }
            }
        }

        // we add TLS secret to store our origin TLS certificate. This looks to be the best way to do this compared to manually creating a manifest and adding the .pem files which could be esposed.
        stage('Deploy TLS Secret') {
            when {
                expression { params.CLUSTER_DEPLOYMENTS }
            }
            steps {
                withCredentials([
                    file(credentialsId: 'CERT', variable: 'CERT'),
                    file(credentialsId: 'KEY', variable: 'KEY')
                ]) {
                    sh """
                    kubectl create secret tls cloudflare-origin-cert \
                    --cert=${CERT} \
                    --key=${KEY} \
                    --dry-run=client -o yaml | kubectl apply -f -
                    """
                }
            }
        } 



        stage('Terraform Destroy') {
            when {
                expression { params.TERRAFORM_DESTROY }
            }
            steps {
                echo "💣 Destroying Terraform Infrastructure..."
                withCredentials([[
                    $class: 'AmazonWebServicesCredentialsBinding',
                    credentialsId: 'my_aws_credentials'
                ]]) {
                    dir("${TERRAFORM_DIR}") {
                        sh """
                            echo "======= Terraform Destroy ======="
                            terraform init -reconfigure
                            terraform destroy -auto-approve
                        """
                    }
                }
            }
        }

    }



    post {

        success {
            echo '✅ Pipeline completed successfully!'
        }

        failure {
            echo '❌ Pipeline failed!'
        }

        always {
            echo '🔔 Pipeline finished running.'
            script {
                if (env.WORKSPACE) {
                    cleanWs()
                } else {
                    echo "⚠️ No workspace found to clean"
                }
            }
        }
    }
}