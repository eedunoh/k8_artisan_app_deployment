pipeline {
    agent any

    // I parametized my terraform workflow
    parameters {
        booleanParam(name: 'PRE_INFRASTRUCTURE', defaultValue: false, description: 'select this option to build all pre-infrastructure configurations like Sonarqube Analysis, Trivy Scans, Image build and push to DockerHub')
        booleanParam(name: 'TERRAFORM_INIT_AND_PLAN', defaultValue: false, description: 'select this option to initialize and plan terraform configurations')
        booleanParam(name: 'TERRAFORM_APPLY', defaultValue: false, description: 'select this option to apply terraform configurations')
        booleanParam(name: 'CLUSTER_DEPLOYMENTS', defaultValue: false, description: 'select this option to deploy app and resources to k8 cluster')
        booleanParam(name: 'TERRAFORM_DESTROY', defaultValue: false, description: 'select this option to destroy terraform configurations')
    }

    environment {
        APP_FOLDER = 'cluster_app_and_resources_deployments/app_folder'
        IMAGE_NAME = 'jackedu/artisan_app'
        IMAGE_TAG = 'latest'
        GIT_URL = 'https://github.com/eedunoh/k8_artisan_app_deployment.git'
        K8_CLUSTER_NAME = 'artisian_app_cluster'
        K8_CLUSTER_REGION = 'eu-north-1'
        MANIFESTS_DIR = 'cluster_app_and_resources_deployments/manifests_yaml'
        TERRAFORM_DIR = 'cluster_app_and_resources_deployments/terraform_files'
        TF_PLAN_FILE = 'tfplan.binary'
        SONAR_PROJECT_NAME = 'artisan_app_sonar'

        // tool 'sonar-scanner' - is a Jenkins command that means: "Go find where the program named 'sonar-scanner' is installed on this computer.
        SCANNER_HOME = tool 'sonar-scanner'
    }


    stages {

        // Clone the git repository/work area
        stage('Clone Git Repository') {
            steps {
                echo "Cleaning workspace and cloning gir repositoy..."
                deleteDir()
                git branch: 'main', url: "${GIT_URL}"
                sh 'ls -lart'
            }
        }


        // Scans Code for quality, maintainability, bugs, code smells, test coverage
        stage('SonarQube Analysis') {
            when {
                expression { params.PRE_INFRASTRUCTURE }
            }
            steps {
                withSonarQubeEnv('sonar') {
                    sh "$SCANNER_HOME/bin/sonar-scanner -Dsonar.projectName=${SONAR_PROJECT_NAME} -Dsonar.projectKey=${SONAR_PROJECT_NAME}"
                }
            }
        }


        // Scans your local source code directory (before you build the image) for security vulnerabilities (CVEs), secrets and misconfigurations.
        stage('Trivy FS Scan') {
            when {
                expression { params.PRE_INFRASTRUCTURE }
            }
            steps {
                sh 'trivy fs --format table -o trivy-fs-report.html .'
            }
        }


        // Your Trivy scan report will be stored in a file. This stage lets you view your scan report on jenkins UI (or terminal).
        stage('Publish Trivy File System Scan Report') {
            when {
                expression { params.PRE_INFRASTRUCTURE }
            }
            steps {
                publishHTML([
                    reportDir: '.',                      // directory where the HTML file is saved
                    reportFiles: 'trivy-fs-report.html',
                    reportName: 'Trivy File System Report',
                    allowMissing: false,
                    keepAll: true,                       // keep old reports from previous builds
                    alwaysLinkToLastBuild: true
                ])
            }
        }


        // Build docker image
        stage('Build Docker Image') {
            when {
                expression { params.PRE_INFRASTRUCTURE }
            }
            steps {
                echo "Building Docker image: ${IMAGE_NAME}:${IMAGE_TAG}"
                dir("${APP_FOLDER}") {
                    script {
                        dockerImage = docker.build("${IMAGE_NAME}:${IMAGE_TAG}")
                    }
                }
            }
        }


        // Clean up Docker build cache
        stage('Clean Docker Builder Cache') {
            when {
                expression { params.PRE_INFRASTRUCTURE }
            }
            steps {
                sh 'docker builder prune -a -f'
            }
        }


        // Push docker image to docker registry (dockerhub)
        stage('Push Docker Image to Docker Hub') {
            when {
                expression { params.PRE_INFRASTRUCTURE }
            }
            steps {
                echo "üöÄ Pushing Docker image to Docker Hub..."
                script {
                    docker.withRegistry('https://index.docker.io/v1/', 'my_docker_hub_secrets') {
                        dockerImage.push("${IMAGE_TAG}")
                    }
                }
            }
        }
    

        stage('Terraform Init') {
            when {
                expression { params.TERRAFORM_INIT_AND_PLAN }
            }
            steps{
                echo "‚öôÔ∏è Initializing Terraform..."
                withCredentials([[
                    $class: 'AmazonWebServicesCredentialsBinding',
                    credentialsId: 'my_aws_credentials'
                ]]) {
                    dir("${TERRAFORM_DIR}") {
                        sh '''
                            echo "======= Terraform Init ======="
                            terraform init
                        '''
                    }
                }
            }
        }


        stage('Terraform Plan') {
            when {
                expression { params.TERRAFORM_INIT_AND_PLAN }
            }
            steps {
                echo "üîç Running Terraform Plan..."
                withCredentials([[
                    $class: 'AmazonWebServicesCredentialsBinding',
                    credentialsId: 'my_aws_credentials'
                ]]) {
                    dir("${TERRAFORM_DIR}") {
                        sh """
                            echo "======= Terraform Plan ======="
                            terraform plan -out=${TF_PLAN_FILE}
                            terraform show -no-color ${TF_PLAN_FILE} > tfplan.txt
                        """
                    }
                    archiveArtifacts artifacts: "${TERRAFORM_DIR}/${TF_PLAN_FILE}, ${TERRAFORM_DIR}/tfplan.txt", onlyIfSuccessful: true
                }
            }
        }

        
        stage('Terraform Apply') {
            when {
                expression { params.TERRAFORM_APPLY }
            }
            steps {
                echo "üöÄ Applying Terraform Plan..."
                withCredentials([[
                    $class: 'AmazonWebServicesCredentialsBinding',
                    credentialsId: 'my_aws_credentials'
                ]]) {
                    dir("${TERRAFORM_DIR}") {
                        sh """
                            echo "======= Terraform Apply ======="
                            terraform apply -auto-approve ${TF_PLAN_FILE}
                        """
                    }
                }
            }
        }


        stage('Deploy To Kubernetes Cluster') {
            when {
                expression { params.CLUSTER_DEPLOYMENTS }
            }
            steps {
                echo "üöÄ Deploying application and resources to Kubernetes cluster..."
                withCredentials([[
                    $class: 'AmazonWebServicesCredentialsBinding',
                    credentialsId: 'my_aws_credentials'
                ]]) {
                    dir("${MANIFESTS_DIR}") {
                        sh """
                     # Set up kubeconfig for EKS
                    aws eks --region ${K8_CLUSTER_REGION} update-kubeconfig --name ${K8_CLUSTER_NAME}


                    # Label nodes based on EC2 Name tag
                    aws ec2 describe-instances \\
                      --filters "Name=instance-state-name,Values=running" \\
                      --query "Reservations[*].Instances[*].[InstanceId, Tags[?Key=='Name'].Value | [0]]" \\
                      --output text | while read i n; do
                        for node in \$(kubectl get nodes -o json | jq -r ".items[] | select(.spec.providerID != null) | .metadata.name"); do
                          if kubectl get node "\$node" -o jsonpath="{.spec.providerID}" | grep -q "\$i"; then
                            kubectl label node "\$node" "role=\$n" --overwrite
                            echo "Labeled \$node as role=\$n"
                          fi
                        done
                    done


                    # Check helm version                            
                    helm version


                    # Add Helm repos
                    helm repo add ingress-nginx https://kubernetes.github.io/ingress-nginx
                    helm repo add prometheus-community https://prometheus-community.github.io/helm-charts
                    helm repo update


                    # Install NGINX ingress controller
                    helm upgrade --install ingress-nginx ingress-nginx/ingress-nginx \\
                    --namespace ingress-nginx --create-namespace \\
                    --wait --timeout 10m


                    # Deploy application (Deployment + Service)
                    kubectl apply -f deployment-service.yml


                    # Install Prometheus + Grafana stack (release name = monitoring)
                    helm upgrade --install monitoring prometheus-community/kube-prometheus-stack \\
                    --namespace monitoring --create-namespace \\
                    -f kube_prometheus_values.yml \\
                    --wait --timeout 10m


                    # Apply ingress rules/ paths based routing
                    kubectl apply -f ingress.yml
                        """
                    }
                }
            }
        }



        stage('Terraform Destroy') {
            when {
                expression { params.TERRAFORM_DESTROY }
            }
            steps {
                echo "üí£ Destroying Terraform Infrastructure..."
                withCredentials([[
                    $class: 'AmazonWebServicesCredentialsBinding',
                    credentialsId: 'my_aws_credentials'
                ]]) {
                    dir("${TERRAFORM_DIR}") {
                        sh """
                            echo "======= Terraform Destroy ======="
                            terraform init -reconfigure
                            terraform destroy -auto-approve
                        """
                    }
                }
            }
        }

    }



    post {

        success {
            echo '‚úÖ Pipeline completed successfully!'
        }

        failure {
            echo '‚ùå Pipeline failed!'
        }

        always {
            echo 'üîî Pipeline finished running.'
            cleanWs()
        }
    }
}