pipeline {
    agent any

    // I parametized my terraform workflow
    parameters {
        booleanParam(name: 'PRE_INFRASTRUCTURE', defaultValue: false, description: 'select this option to build all pre-infrastructure configurations like Sonarqube Analysis, Trivy Scans, Image build and push to DockerHub')
        booleanParam(name: 'TERRAFORM_INIT_AND_PLAN', defaultValue: false, description: 'select this option to initialize and plan terraform configurations')
        booleanParam(name: 'TERRAFORM_APPLY', defaultValue: false, description: 'select this option to apply terraform configurations')
        booleanParam(name: 'CLUSTER_DEPLOYMENTS', defaultValue: false, description: 'select this option to deploy app and resources to k8 cluster')
        booleanParam(name: 'TERRAFORM_DESTROY', defaultValue: false, description: 'select this option to destroy terraform configurations')
    }

    environment {
        APP_FOLDER='cluster_app_and_resources_deployments/app_folder'
        IMAGE_NAME='jackedu/artisan_app'
        IMAGE_TAG='latest'
        GIT_URL='https://github.com/eedunoh/k8_artisan_app_deployment.git'
        K8_CLUSTER_NAME='artisian_app_cluster'
        K8_CLUSTER_REGION='eu-north-1'
        MANIFESTS_DIR='cluster_app_and_resources_deployments/manifests_yaml'
        TERRAFORM_DIR='cluster_app_and_resources_deployments/terraform_files'
        TF_PLAN_FILE='tfplan.binary'
        SONAR_PROJECT_NAME='artisan_app_sonar'
        EKS_APP_NODE='app_worker_node' 
        EKS_MONITORING_NODE='monitoring_node'

        // tool 'sonar-scanner' - is a Jenkins command that means: "Go find where the program named 'sonar-scanner' is installed on this computer.
        SCANNER_HOME = tool 'sonar-scanner'
    }


    stages {

        // Clone the git repository/work area
        stage('Clone Git Repository') {
            steps {
                echo "Cleaning workspace and cloning gir repositoy..."
                deleteDir()
                git branch: 'main', url: "${GIT_URL}"
                sh 'ls -lart'
            }
        }


        // Scans Code for quality, maintainability, bugs, code smells, test coverage
        stage('SonarQube Analysis') {
            when {
                expression { params.PRE_INFRASTRUCTURE }
            }
            steps {
                withSonarQubeEnv('sonar') {
                    sh "$SCANNER_HOME/bin/sonar-scanner -Dsonar.projectName=${SONAR_PROJECT_NAME} -Dsonar.projectKey=${SONAR_PROJECT_NAME}"
                }
            }
        }


        // Scans your local source code directory (before you build the image) for security vulnerabilities (CVEs), secrets and misconfigurations.
        stage('Trivy FS Scan') {
            when {
                expression { params.PRE_INFRASTRUCTURE }
            }
            steps {
                sh 'trivy fs --format table -o trivy-fs-report.html .'
            }
        }


        // Your Trivy scan report will be stored in a file. This stage lets you view your scan report on jenkins UI (or terminal).
        stage('Publish Trivy File System Scan Report') {
            when {
                expression { params.PRE_INFRASTRUCTURE }
            }
            steps {
                publishHTML([
                    reportDir: '.',                      // directory where the HTML file is saved
                    reportFiles: 'trivy-fs-report.html',
                    reportName: 'Trivy File System Report',
                    allowMissing: false,
                    keepAll: true,                       // keep old reports from previous builds
                    alwaysLinkToLastBuild: true
                ])
            }
        }


        // Build docker image
        stage('Build Docker Image') {
            when {
                expression { params.PRE_INFRASTRUCTURE }
            }
            steps {
                echo "Building Docker image: ${IMAGE_NAME}:${IMAGE_TAG}"
                dir("${APP_FOLDER}") {
                    script {
                        dockerImage = docker.build("${IMAGE_NAME}:${IMAGE_TAG}")
                    }
                }
            }
        }


        // Clean up Docker build cache
        stage('Clean Docker Builder Cache') {
            when {
                expression { params.PRE_INFRASTRUCTURE }
            }
            steps {
                sh 'docker builder prune -a -f'
            }
        }


        // Push docker image to docker registry (dockerhub)
        stage('Push Docker Image to Docker Hub') {
            when {
                expression { params.PRE_INFRASTRUCTURE }
            }
            steps {
                echo "üöÄ Pushing Docker image to Docker Hub..."
                script {
                    docker.withRegistry('https://index.docker.io/v1/', 'my_docker_hub_secrets') {
                        dockerImage.push("${IMAGE_TAG}")
                    }
                }
            }
        }
    

        stage('Terraform Init') {
            when {
                expression { params.TERRAFORM_INIT_AND_PLAN }
            }
            steps{
                echo "‚öôÔ∏è Initializing Terraform..."
                withCredentials([[
                    $class: 'AmazonWebServicesCredentialsBinding',
                    credentialsId: 'my_aws_credentials'
                ]]) {
                    dir("${TERRAFORM_DIR}") {
                        sh '''
                            echo "======= Terraform Init ======="
                            terraform init
                        '''
                    }
                }
            }
        }


        stage('Terraform Plan') {
            when {
                expression { params.TERRAFORM_INIT_AND_PLAN }
            }
            steps {
                echo "üîç Running Terraform Plan..."
                withCredentials([[
                    $class: 'AmazonWebServicesCredentialsBinding',
                    credentialsId: 'my_aws_credentials'
                ]]) {
                    dir("${TERRAFORM_DIR}") {
                        sh """
                            echo "======= Terraform Plan ======="
                            terraform plan -out=${TF_PLAN_FILE}
                            terraform show -no-color ${TF_PLAN_FILE} > tfplan.txt
                        """
                    }
                    archiveArtifacts artifacts: "${TERRAFORM_DIR}/${TF_PLAN_FILE}, ${TERRAFORM_DIR}/tfplan.txt", onlyIfSuccessful: true
                }
            }
        }

        
        stage('Terraform Apply') {
            when {
                expression { params.TERRAFORM_APPLY }
            }
            steps {
                echo "üöÄ Applying Terraform Plan..."
                withCredentials([[
                    $class: 'AmazonWebServicesCredentialsBinding',
                    credentialsId: 'my_aws_credentials'
                ]]) {
                    dir("${TERRAFORM_DIR}") {
                        sh """
                            echo "======= Terraform Apply ======="
                            terraform apply -auto-approve ${TF_PLAN_FILE}
                        """
                    }
                }
            }
        }


        stage('Deploy To Kubernetes Cluster') {
            when {
                expression { params.CLUSTER_DEPLOYMENTS }
            }
            steps {
                echo "üöÄ Deploying application and resources to Kubernetes cluster..."
                withCredentials([[
                    $class: 'AmazonWebServicesCredentialsBinding',
                    credentialsId: 'my_aws_credentials'
                ]]) {
                    dir("${MANIFESTS_DIR}") {
                        sh '''
                     # Set up kubeconfig for EKS
                    aws eks --region ${K8_CLUSTER_REGION} update-kubeconfig --name ${K8_CLUSTER_NAME}


                    # Label monitoring nodes
                    aws ec2 describe-instances \
                    --filters "Name=instance-state-name,Values=running" \
                    --query "Reservations[*].Instances[*].[InstanceId,Tags[?Key=='Name'].Value | [0]]" \
                    --output text | while read -r instance_id aws_name; do
                        if [ "$aws_name" = ${EKS_MONITORING_NODE} ]; then
                            k8s_node=$(kubectl get nodes -o jsonpath='{range .items[*]}{.metadata.name}{" "}{.spec.providerID}{"\n"}{end}' \
                            | grep "$instance_id" | awk '{print $1}')
                            if [ -n "$k8s_node" ]; then
                                kubectl label node "$k8s_node" node-role.kubernetes.io/monitoring-node= --overwrite
                                echo "‚úÖ Labeled $k8s_node as monitoring-node"
                            fi
                        fi
                    done

                    # Label app nodes
                    aws ec2 describe-instances \
                    --filters "Name=instance-state-name,Values=running" \
                    --query "Reservations[*].Instances[*].[InstanceId,Tags[?Key=='Name'].Value | [0]]" \
                    --output text | while read -r instance_id aws_name; do
                        if [ "$aws_name" = ${EKS_APP_NODE} ]; then
                            k8s_node=$(kubectl get nodes -o jsonpath='{range .items[*]}{.metadata.name}{" "}{.spec.providerID}{"\n"}{end}' \
                            | grep "$instance_id" | awk '{print $1}')
                            if [ -n "$k8s_node" ]; then
                                kubectl label node "$k8s_node" node-role.kubernetes.io/app-worker-node= --overwrite
                                echo "‚úÖ Labeled $k8s_node as app-worker-node"
                            fi
                        fi
                    done


                    # Check helm version                            
                    helm version


                    # Add Helm repos
                    helm repo add ingress-nginx https://kubernetes.github.io/ingress-nginx
                    helm repo add prometheus-community https://prometheus-community.github.io/helm-charts
                    helm repo update


                    # Install NGINX ingress controller
                    helm upgrade --install ingress-nginx ingress-nginx/ingress-nginx \\
                    --namespace ingress-nginx --create-namespace \\
                    --wait --timeout 10m


                    # Install EBS CSI driver so Kubernetes can dynamically provision EBS volumes for PVC else PVC will remain in Pending state
                    kubectl apply -k "github.com/kubernetes-sigs/aws-ebs-csi-driver/deploy/kubernetes/overlays/stable/ecr/?ref=release-1.25"


                    # Deploy application (Deployment + Service)
                    kubectl apply -f deployment-service.yml


                    # Install Prometheus + Grafana stack (release name = monitoring)
                    helm upgrade --install monitoring prometheus-community/kube-prometheus-stack \\
                    -f kube_prometheus_values.yml \\
                    --wait --timeout 10m


                    # Apply ingress rules/ paths based routing
                    kubectl apply -f ingress.yml
                        '''
                    }
                }
            }
        }

        // we add TLS secret to store our origin TLS certificate. This looks to be the best way to do this compared to manually creating a manifest and adding the .pem files which could be esposed.
        stage('Deploy TLS Secret') {
            when {
                expression { params.CLUSTER_DEPLOYMENTS }
            }
            steps { 
                withCredentials([ 
                    file(credentialsId: 'cloudflare-cert', variable: 'CERT'), 
                    file(credentialsId: 'cloudflare-key', variable: 'KEY') 
                    ]) { 
                        sh """ 
                        kubectl create secret tls cloudflare-origin-cert  
                        --cert=$CERT  
                        --key=$KEY 
                        --dry-run=client -o yaml | kubectl apply -f - 
                        """ 
                    } 
                } 
            } 



        stage('Terraform Destroy') {
            when {
                expression { params.TERRAFORM_DESTROY }
            }
            steps {
                echo "üí£ Destroying Terraform Infrastructure..."
                withCredentials([[
                    $class: 'AmazonWebServicesCredentialsBinding',
                    credentialsId: 'my_aws_credentials'
                ]]) {
                    dir("${TERRAFORM_DIR}") {
                        sh """
                            echo "======= Terraform Destroy ======="
                            terraform init -reconfigure
                            terraform destroy -auto-approve
                        """
                    }
                }
            }
        }

    }



    post {

        success {
            echo '‚úÖ Pipeline completed successfully!'
        }

        failure {
            echo '‚ùå Pipeline failed!'
        }

        always {
            echo 'üîî Pipeline finished running.'
            cleanWs()
        }
    }
}